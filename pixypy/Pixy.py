import serial
import easing_functions
import numpy as np


class Pixy:
    '''
    A Pixycam Emulator class. Communicates over UART to simulate a working Pixycam
    '''

    def __init__(self):
        self.preamble =bytearray([0xAA, 0x55, 0xFF, 0xFF, 0xFF, 0xFF])
        self.suffix = bytearray([0x0A, 0x00, 0x0A, 0x0A])
        self.x: float = 0
        self.y: float = 0
        self.port = ''
        self.easing_fn = 'CubicEaseIn'
        self.steps = 10
        self.ser = None

    def _validate_coords(self, v, is_x):
        '''
        Clamp x and y to valid coordinate
        '''
        v = int(v)
        if is_x and (v > 312):
            v = 312
        elif is_x and (v < 0):
            v = 0
        elif not is_x and (v > 205):
            v = 205
        elif not is_x and (v < 0):
            v = 0

        return v

    def _get_easing_fn(self, function):

        try:

            if hasattr(easing_functions, function) and callable(fn := getattr(easing_functions, function)):
                return fn
        except Exception as e:
            print(e)

        return None

    def move_left(self, amt, steps=0, mode=None):
        '''
        Emulate the response generated by an object moving left by amt
        '''
        amt = int(amt)
        if not mode:
            mode = self.easing_fn

        if steps == 0:
            steps = self.default_steps
        easing = self._get_easing_fn(mode)
        step = easing(start=self.x, end=self._validate_coords(
            self.x - amt, True), duration=steps)
        self.send_command(step)

    def move_right(self, amt, steps=0, mode=None):
        '''
        Emulate the response generated by an object moving right by amt
        '''
        amt = int(amt)
        if not mode:
            mode = self.easing_fn

        if steps == 0:
            steps = self.default_steps
        easing = self._get_easing_fn(mode)
        step = easing(start=self.x, end=self._validate_coords(
            self.x + amt, True), duration=steps)
        self.send_command(step)

    def move_up(self, amt, steps=0, mode=None):
        '''
        Emulate the response generated by an object moving up by amt
        '''
        if not mode:
            mode = self.easing_fn

        if steps == 0:
            steps = self.default_steps
        easing = self._get_easing_fn(mode)
        step = easing(start=self.y, end=self._validate_coords(
            self.y - amt, False), duration=steps)

    def move_down(self, amt, steps=0, mode=None):
        '''
        emulate the response generated by an object moving down by amt
        '''
        amt = int(amt)
        if not mode:
            mode = self.easing_fn

        if steps == 0:
            steps = self.default_steps
        easing = self._get_easing_fn(mode)
        step = easing(start=self.y, end=self._validate_coords(
            self.y + amt, False), duration=steps)

    def go_to(self, x, y, steps=0, mode=None):
        '''
        Emulate the response generated by an object moving to the specified location
        '''
        if not mode:
            mode = self.easing_fn

        if steps == 0:
            steps = self.default_steps
        easing = self._get_easing_fn(mode)
        step_x = easing(
            start=self.x, end=self._validate_coords(x, True), duration=steps)
        step_y = easing(
            start=self.x, end=self._validate_coords(y, False), duration=steps)

    def begin(self, options):
        self.x = self._validate_coords(options['coords'][0], True)
        self.y = self._validate_coords(options['coords'][1], False)
        self.port = options['port']
        self.easing_fn = options['easing_fn']
        self.default_steps = options['steps']
        self.baud_rate = options['baud_rate']
        try:
            self.ser = serial.Serial(port=self.port, baudrate=self.baud_rate)
        except OSError:
            self.ser = serial.Serial(port=self.port, baudrate=self.baud_rate,  rtscts=True, dsrdtr=True)

    def send_command(self, x_steps, y_steps):
        if not self.ser.is_open:
            self.ser.open()
        for step in range(steps.duration + 1):
            data = self.preamble
            data.append(np.int16(np.floor(x_steps(step))) & 0xFF)
            data.append(np.int16(np.floor(x_steps(step))) & 0xFF00)
            data.append(np.int16(np.floor(y_steps(step))) & 0xFF)
            data.append(np.int16(np.floor(y_steps(step))) & 0xFF00)
            data.append(self.suffix)
            self.ser.write(data)

    def send_command(self, steps, is_x=True):
        if not self.ser.is_open:
            self.ser.open()
        for step in range(steps.duration + 1):
            data = self.preamble
            if is_x:
                data.append(np.int16(np.floor(steps(step))) & 0xFF)
                data.append(np.int16(np.floor(steps(step))) & 0xFF00)
                data.append(np.int16(np.floor(self.y)) & 0xFF)
                data.append(np.int16(np.floor(self.y)) & 0xFF00)
            else:
                data.append(np.int16(np.floor(self.x)) & 0xFF)
                data.append(np.int16(np.floor(self.x)) & 0xFF00)
                data.append(np.int16(np.floor(steps(step))) & 0xFF)
                data.append(np.int16(steps(np.floor(step))) & 0xFF00)
            data.append(self.suffix)
            self.ser.write(data)


if __name__ == '__main__':
    print("Pixy is a library and should only be used as an import!")
    exit(1)
